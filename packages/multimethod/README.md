# Arrows - multimethod

![CircleCI](https://img.shields.io/circleci/build/github/caderek/arrows)
![David (path)](https://img.shields.io/david/caderek/arrows?path=packages%2Fmultimethod)
![Codecov](https://img.shields.io/codecov/c/github/caderek/arrows?token=c6adb715d638431786fefe69ca08ab00)
![npm bundle size (scoped)](https://img.shields.io/bundlephobia/minzip/@arrows/multimethod)

## Introduction

Multimethod library provides special a tiny set of higher-order functions, that help you to control the flow of your program in a readable and extensible way.

This implementation allows you to create powerful, immutable multimethods in a functional way.

## Notes

There should not be any major changes in the API, but there are no guarantees. You should probably wait for the version `1.0.0` (soon!) to use it on production.

I will release stable version after some more polishing and [dogfooding](https://en.wikipedia.org/wiki/Eating_your_own_dog_food).

## API

<!-- Generated by documentation.js. Update this documentation by updating the source code. -->

#### Table of Contents

- [multi](#multi)
  - [Parameters](#parameters)
  - [Examples](#examples)
- [method](#method)
  - [Parameters](#parameters-1)
  - [Examples](#examples-1)
- [fromMulti](#frommulti)
  - [Parameters](#parameters-2)
  - [Examples](#examples-2)

### multi

Creates multimethod - a function that can dynamically choose proper implementation,
based on arbitrary dispatch of its arguments

#### Parameters

- `dispatch` The function that calculates values for matching
- `methods` Arbitrary number of partially applied methods

Returns an immutable multimethod that can be used as ordinary function

#### Interface:

```
(dispatch?, method1?, method2?, ..., methodN?) => multimethod
```

#### Examples

Create multimethod with the default dispatch (identity function) and no methods:

```javascript
const fn = multi()
fn('foo') // -> throws an Error (because of no matching methods), but useful as a base for extensions
```

Create multimethod with a custom dispatch and no methods:

```javascript
const fn = multi((x) => typeof x)
fn('foo') // -> throws an Error (because of no matching methods), but useful as a base for extensions
```

Create multimethod with the default dispatch (identity function) and some methods:

```javascript
const makeSound = multi(
  method('cat', () => 'Meow!'),
  method('dog', () => 'Woof!'),
  method(() => 'Hello!'), // default method
)

makeSound('cat') // -> 'Meow!'
makeSound('dog') // -> 'Woof!'
makeSound('cow') // -> 'Hello!' (that's a rather unusual cow)
```

Create multimethod with a custom dispatch and some methods:

```javascript
const multiply = multi(
  (multiplier, x) => [typeof multiplier, typeof x],
  method(['number', 'number'], (multiplier, x) => x * multiplier),
  method(['number', 'string'], (multiplier, x) => x.repeat(multiplier)),
)

multiply(2, 5) // -> 10
multiply(3, 'Beetlejuice! ') // -> 'Beetlejuice! Beetlejuice! Beetlejuice! ' (do not read it out loud)
multiply(2, [1, 2, 3]) // -> throws an Error (no match and no default method for these arguments)
```

### method

Adds method to a multimethod

#### Parameters

- `caseValue` The value to which the result of dispatch function is matched (if function, then is executed with output of dispatch function)
- `correspondingValue` The value that function should return on matching case (if function, then is executed with input arguments)
- `multimethod` Multimethod on which you want to base new multimethod

Returns a new multimethod (the base one is unchanged)

#### Interface:

```
(caseValue?, correspondingValue) => (multimethod) => new_multimethod
```

#### Examples

Default method as function:

```javascript
const sayHello = multi((user) => user.lang)

const sayHelloWithDefault = method((user) => `Hello ${usr.name}!`)(sayHello)

sayHelloWithDefault({ name: 'Alejandro', lang: 'es' }) // -> 'Hello Alejandro!'
```

Default method as other value:

```javascript
const sayHello = multi(() => user.lang)

const sayHelloWithDefault = method('Hello!')(sayHello)

sayHelloWithDefault({ name: 'Alejandro', lang: 'es' }) // -> 'Hello!'
```

Case method with caseValue as ordinary value and correspondingValue as a function:

```javascript
const add = multi((a, b) => [typeof a, typeof b])

const extendedAdd = method(['number', 'number'], (a, b) => a + b)(add)

extendedAdd(1, 2) // -> 3
```

Case method with caseValue and correspondingValue as ordinary values:

```javascript
const getHexColor = multi() // Uses identity function (x => x) as default dispatch

const extendedGetHexColor = method('red', '#FF0000')(getHexColor)

extendedGetHexColor('red') // -> '#FF0000'
```

Case method with caseValue as a function and correspondingValue as ordinary value:

```javascript
class Enemy {}
const is = (prototype) => (value) => value instanceof prototype

const greet = multi() // Uses identity function (x => x) as default dispatch

// Matches, when case function executed with dispatch value returns truthy value
const extendedGreet = method(is(Enemy), 'Goodbye!')(greet)

extendedGreet(new Enemy()) // -> 'Goodbye!'
```

Case method with caseValue and correspondingValue as functions:

```javascript
class Car {
  drive() {
    return 'driving...'
  }
}
class Human {
  walk() {
    return 'walking...'
  }
}
const is = (prototype) => (value) => value instanceof prototype

const go = multi(
  // Uses identity function (x => x) as default dispatch
  method(is(Car), (entity) => entity.drive()), // lets add one case to original multimethod
)

const extendedGo = method(is(Human), (entity) => entity.walk())(go)

extendedGo(new Car()) // -> 'driving...'
extendedGo(new Human()) // -> 'walking...'
```

### fromMulti

Allows to create new multimethods from existing ones in a simple way.

It works like functional `pipe`, but with additional checks,
specialized error messages and type checking.

#### Parameters

- `methods` Arbitrary number of partially applied methods
- `multimethod` Multimethod on which you want to base new multimethod

Returns a new multimethod (the base one is unchanged)

#### Interface:

```
(method1, method2?, ..., methodN?) => (multimethod) => new_multimethod
```

#### Examples

Create new multimethod using existing one as a base:

```javascript
const add = multi(
  (a, b) => [typeof a, typeof b],
  method(['number', 'number'], (a, b) => a + b),
  method(['string', 'string'], (a, b) => `${a}${b}`),
)

const extendedAdd = fromMulti(
  method(['bigint', 'bigint'], (a, b) => a + b),
  method(['number', 'bigint'], (a, b) => BigInt(a) + b),
  method(['bigint', 'number'], (a, b) => a + BigInt(b)),
)(add)

extendedAdd(1, 2) // -> 3
extendedAdd('foo', 'bar') // -> 'foobar'
extendedAdd(2n, 3n) // -> 5n
extendedAdd(5, 5n) // -> 10n
extendedAdd(9n, 2) // -> 11n
```

---
